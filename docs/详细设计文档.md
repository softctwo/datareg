# 银行重要数据跨境数据管控系统 - 详细设计文档

## 1. 系统架构设计

### 1.1 总体架构

本系统采用前后端分离的微服务架构，主要包括以下几个层次：

```
┌─────────────────────────────────────────────────────────────┐
│                        前端层 (Presentation Layer)                │
│              React 18 + TypeScript + Ant Design                │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                        API网关层 (API Gateway)                   │
│                    FastAPI + JWT认证 + 路由转发                    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                       业务服务层 (Service Layer)                   │
│         数据资产服务 | 场景管理服务 | 风险评估服务 | 审批服务        │
│         监控审计服务 | 用户权限服务 | 拦截脱敏服务                    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                        数据访问层 (Data Layer)                     │
│                    SQLAlchemy ORM + Repository                   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                         数据存储层 (Storage Layer)                  │
│              PostgreSQL (主数据库) + Redis (缓存)                │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 技术栈选择

#### 1.2.1 后端技术栈

| 组件 | 技术选择 | 版本 | 选择理由 |
|------|----------|------|----------|
| Web框架 | FastAPI | 0.104.1 | 高性能、自动API文档、类型提示支持 |
| 数据库 | PostgreSQL | 14+ | 强一致性、JSON支持、事务支持 |
| ORM | SQLAlchemy | 2.0.23 | 成熟稳定、支持异步操作 |
| 数据库迁移 | Alembic | 1.12.1 | 数据库版本控制、自动迁移 |
| 认证授权 | JWT | - | 无状态、易于扩展 |
| 任务队列 | Celery | 5.3.4 | 异步任务处理、定时任务 |
| 缓存 | Redis | 5.0.1 | 高性能、支持多种数据结构 |
| 数据处理 | Pandas | 2.1.3 | 强大的数据分析能力 |

#### 1.2.2 前端技术栈

| 组件 | 技术选择 | 版本 | 选择理由 |
|------|----------|------|----------|
| 框架 | React | 18.2.0 | 组件化、生态丰富 |
| 语言 | TypeScript | 5.3.3 | 类型安全、开发效率 |
| 路由 | React Router | 6.20.0 | 单页应用路由管理 |
| UI框架 | Ant Design | 5.12.0 | 企业级UI组件库 |
| HTTP客户端 | Axios | 1.6.2 | 支持Promise、拦截器 |
| 状态管理 | React Hooks | - | 轻量级状态管理 |
| 图表 | ECharts | 5.4.3 | 功能丰富、性能优秀 |
| 构建工具 | Vite | 5.0.8 | 快速构建、热更新 |

### 1.3 部署架构

```
┌─────────────────────────────────────────────────────────────┐
│                        负载均衡器 (Load Balancer)                  │
│                              Nginx                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────┐    ┌─────────────────────┐
│     前端容器          │    │     后端容器          │
│   (React + Nginx)    │    │    (FastAPI)        │
└─────────────────────┘    └─────────────────────┘
                                     │
                                     ▼
┌─────────────────────┐    ┌─────────────────────┐
│    PostgreSQL主库     │    │    Redis缓存         │
│      (数据持久化)     │    │      (会话缓存)       │
└─────────────────────┘    └─────────────────────┘
```

## 2. 模块设计

### 2.1 数据资产分类分级模块

#### 2.1.1 模块架构

```
数据资产分类分级模块
├── 数据扫描器 (DataScanner)
│   ├── 数据库连接管理
│   ├── 表结构扫描
│   └── 字段信息提取
├── 分类引擎 (ClassificationEngine)
│   ├── 规则匹配
│   ├── 机器学习分类
│   └── 人工校准
├── 血缘分析器 (LineageAnalyzer)
│   ├── 上游依赖分析
│   ├── 下游影响分析
│   └── 可视化展示
└── 标签管理器 (TagManager)
    ├── 标签定义
    ├── 标签关联
    └── 标签搜索
```

#### 2.1.2 核心类设计

```python
class DataAssetService:
    """数据资产服务类"""

    def scan_database(self, db_config: DatabaseConfig) -> List[DataAsset]:
        """扫描数据库，发现数据资产"""
        pass

    def classify_asset(self, asset: DataAsset) -> DataClassification:
        """对数据资产进行分类分级"""
        pass

    def analyze_lineage(self, asset_id: int) -> DataLineage:
        """分析数据血缘关系"""
        pass

    def apply_tags(self, asset_id: int, tags: List[str]) -> None:
        """为数据资产应用标签"""
        pass
```

#### 2.1.3 数据流程

```
数据库 → 数据扫描器 → 原始资产信息 → 分类引擎 → 分类结果 → 血缘分析器 → 血缘关系 → 标签管理器 → 最终资产
```

### 2.2 跨境传输场景管理模块

#### 2.2.1 模块架构

```
跨境传输场景管理模块
├── 场景管理器 (SceneManager)
│   ├── 场景创建
│   ├── 场景更新
│   ├── 场景查询
│   └── 场景删除
├── 接收方管理器 (RecipientManager)
│   ├── 接收方验证
│   ├── 风险评估
│   └── 黑名单检查
├── 要素管理器 (ElementManager)
│   ├── 传输要素配置
│   ├── 安全措施定义
│   └── 合规检查
└── 状态管理器 (StatusManager)
    ├── 状态流转
    ├── 通知提醒
    └── 有效期管理
```

#### 2.2.2 状态机设计

```
状态流转图：
草稿 → 待审批 → 已批准 → 已过期
   ↓       ↓        ↓
 已拒绝   已拒绝   已暂停
```

#### 2.2.3 核心类设计

```python
class ScenarioService:
    """场景服务类"""

    def create_scenario(self, scenario: ScenarioCreate) -> CrossBorderScenario:
        """创建跨境场景"""
        pass

    def submit_approval(self, scenario_id: int) -> bool:
        """提交审批"""
        pass

    def approve_scenario(self, scenario_id: int, comment: str) -> bool:
        """批准场景"""
        pass

    def reject_scenario(self, scenario_id: int, reason: str) -> bool:
        """拒绝场景"""
        pass

    def check_expiry(self) -> List[int]:
        """检查过期场景"""
        pass
```

### 2.3 风险评估引擎模块

#### 2.3.1 模块架构

```
风险评估引擎模块
├── 评估管理器 (AssessmentManager)
│   ├── PIA评估模板
│   ├── DPIA评估模板
│   └── 自定义评估模板
├── 风险计算器 (RiskCalculator)
│   ├── 多维度评分
│   ├── 权重配置
│   └── 风险等级计算
├── 阈值检查器 (ThresholdChecker)
│   ├── 个人信息阈值
│   ├── 敏感信息阈值
│   └── 接近阈值预警
└── 报告生成器 (ReportGenerator)
    ├── 评估报告
    ├── 风险报告
    └── 建议报告
```

#### 2.3.2 风险评估算法

```python
class RiskCalculator:
    """风险计算器"""

    # 权重配置
    WEIGHTS = {
        'legal_environment': 0.30,  # 法律环境
        'data_volume': 0.25,        # 数据规模
        'security_measures': 0.25,  # 安全措施
        'data_sensitivity': 0.20    # 数据敏感性
    }

    def calculate_overall_risk(self, assessment: RiskAssessment) -> RiskLevel:
        """计算综合风险等级"""
        scores = {
            'legal_environment': assessment.legal_environment_score,
            'data_volume': assessment.data_volume_score,
            'security_measures': assessment.security_measures_score,
            'data_sensitivity': assessment.data_sensitivity_score
        }

        # 加权平均计算综合评分
        overall_score = sum(
            score * self.WEIGHTS[dimension]
            for dimension, score in scores.items()
        )

        # 根据评分确定风险等级
        if overall_score >= 80:
            return RiskLevel.LOW
        elif overall_score >= 60:
            return RiskLevel.MEDIUM
        elif overall_score >= 40:
            return RiskLevel.HIGH
        else:
            return RiskLevel.CRITICAL
```

### 2.4 拦截与脱敏模块

#### 2.4.1 模块架构

```
拦截与脱敏模块
├── 策略引擎 (PolicyEngine)
│   ├── 白名单策略
│   ├── 黑名单策略
│   ├── 核心数据策略
│   └── 动态策略配置
├── 脱敏引擎 (DesensitizationEngine)
│   ├── 身份证脱敏器
│   ├── 手机号脱敏器
│   ├── 银行卡脱敏器
│   ├── 姓名脱敏器
│   └── 邮箱脱敏器
├── 决策引擎 (DecisionEngine)
│   ├── 规则匹配
│   ├── 风险评估
│   └── 决策执行
└── 审计记录器 (AuditRecorder)
    ├── 操作日志
    ├── 决策日志
    └── 异常日志
```

#### 2.4.2 脱敏算法实现

```python
class DesensitizationEngine:
    """脱敏引擎"""

    def desensitize_id_card(self, id_card: str) -> str:
        """身份证号脱敏：保留前3位后4位"""
        if len(id_card) >= 7:
            return id_card[:3] + "*" * (len(id_card) - 7) + id_card[-4:]
        return "*" * len(id_card)

    def desensitize_phone(self, phone: str) -> str:
        """手机号脱敏：保留前3位后4位"""
        if len(phone) >= 7:
            return phone[:3] + "*" * (len(phone) - 7) + phone[-4:]
        return "*" * len(phone)

    def desensitize_bank_card(self, card_no: str) -> str:
        """银行卡号脱敏：保留后4位"""
        if len(card_no) >= 4:
            return "*" * (len(card_no) - 4) + card_no[-4:]
        return "*" * len(card_no)

    def desensitize_name(self, name: str) -> str:
        """姓名假名化：SHA256哈希"""
        import hashlib
        return hashlib.sha256(name.encode('utf-8')).hexdigest()

    def desensitize_email(self, email: str) -> str:
        """邮箱脱敏：遮掩@前部分"""
        if '@' in email:
            local, domain = email.split('@', 1)
            if len(local) <= 2:
                masked_local = "*" * len(local)
            else:
                masked_local = local[0] + "*" * (len(local) - 2) + local[-1]
            return masked_local + "@" + domain
        return "*" * len(email)
```

### 2.5 传输审批流程模块

#### 2.5.1 模块架构

```
传输审批流程模块
├── 流程引擎 (WorkflowEngine)
│   ├── 流程定义
│   ├── 流程实例化
│   ├── 流程执行
│   └── 流程监控
├── 任务管理器 (TaskManager)
│   ├── 任务创建
│   ├── 任务分配
│   ├── 任务完成
│   └── 任务超时
├── 通知服务 (NotificationService)
│   ├── 邮件通知
│   ├── 站内信通知
│   └── 短信通知（预留）
└── 记录管理器 (RecordManager)
    ├── 审批记录
    ├── 传输记录
    └── 历史查询
```

#### 2.5.2 审批流程配置

```python
class ApprovalWorkflow:
    """审批工作流配置"""

    def __init__(self):
        self.workflows = {
            'low_risk': {
                'approvers': ['department_manager'],
                'required_approvals': 1,
                'timeout_hours': 24
            },
            'medium_risk': {
                'approvers': ['department_manager', 'compliance_officer'],
                'required_approvals': 2,
                'timeout_hours': 48
            },
            'high_risk': {
                'approvers': ['department_manager', 'compliance_officer', 'risk_manager'],
                'required_approvals': 3,
                'timeout_hours': 72
            },
            'critical_risk': {
                'approvers': ['department_manager', 'compliance_officer', 'risk_manager', 'cto'],
                'required_approvals': 4,
                'timeout_hours': 168  # 一周
            }
        }

    def get_workflow_config(self, risk_level: str) -> dict:
        """获取风险等级对应的审批流程配置"""
        return self.workflows.get(risk_level, self.workflows['medium_risk'])
```

### 2.6 监控与审计模块

#### 2.6.1 模块架构

```
监控与审计模块
├── 监控仪表盘 (Dashboard)
│   ├── 实时统计
│   ├── 趋势分析
│   ├── 分布图表
│   └── 预警信息
├── 异常检测器 (AnomalyDetector)
│   ├── 统计异常检测
│   ├── 规则异常检测
│   └── 机器学习异常检测
├── 审计日志器 (AuditLogger)
│   ├── 操作日志
│   ├── 访问日志
│   ├── 系统日志
│   └── 安全日志
└── 报告生成器 (ReportGenerator)
    ├── 统计报告
    ├── 审计报告
    └── 合规报告
```

#### 2.6.2 异常检测算法

```python
class AnomalyDetector:
    """异常检测器"""

    def detect_volume_anomaly(self, current_volume: int, historical_volumes: List[int]) -> bool:
        """检测传输量异常"""
        if not historical_volumes:
            return False

        # 计算历史平均值和标准差
        mean_volume = sum(historical_volumes) / len(historical_volumes)
        variance = sum((x - mean_volume) ** 2 for x in historical_volumes) / len(historical_volumes)
        std_dev = variance ** 0.5

        # 如果当前传输量超过平均值3个标准差，则认为异常
        threshold = mean_volume + 3 * std_dev
        return current_volume > threshold

    def detect_frequency_anomaly(self, request_count: int, time_window: int) -> bool:
        """检测请求频率异常"""
        # 设置阈值：1分钟内超过100次请求
        if time_window <= 60:
            return request_count > 100
        else:
            # 转换为每分钟请求次数
            per_minute = request_count * 60 / time_window
            return per_minute > 100
```

## 3. 数据库设计

### 3.1 设计原则

1. **规范化设计**：遵循第三范式，避免数据冗余
2. **性能优化**：合理使用索引，提高查询效率
3. **扩展性**：预留扩展字段，支持未来需求变更
4. **审计要求**：完整记录数据变更历史
5. **安全考虑**：敏感数据加密存储

### 3.2 核心表设计

详细的数据库设计见《数据库设计文档》，这里列出主要表结构：

#### 3.2.1 用户权限相关表

- `users` - 用户表
- `roles` - 角色表
- `permissions` - 权限表
- `user_roles` - 用户角色关联表
- `role_permissions` - 角色权限关联表

#### 3.2.2 数据资产相关表

- `data_assets` - 数据资产表
- `data_classifications` - 数据分类表
- `sensitive_tags` - 敏感标签表
- `asset_tag_association` - 资产标签关联表

#### 3.2.3 跨境场景相关表

- `cross_border_scenarios` - 跨境场景表
- `transfer_approvals` - 传输审批表
- `risk_assessments` - 风险评估表

#### 3.2.4 审计相关表

- `audit_logs` - 审计日志表
- `system_logs` - 系统日志表
- `security_events` - 安全事件表

### 3.3 索引设计

```sql
-- 用户表索引
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_is_active ON users(is_active);

-- 数据资产表索引
CREATE INDEX idx_data_assets_name ON data_assets(asset_name);
CREATE INDEX idx_data_assets_code ON data_assets(asset_code);
CREATE INDEX idx_data_assets_level ON data_assets(data_level);
CREATE INDEX idx_data_assets_classification ON data_assets(classification_id);
CREATE INDEX idx_data_assets_created ON data_assets(created_at);

-- 场景表索引
CREATE INDEX idx_scenarios_name ON cross_border_scenarios(scenario_name);
CREATE INDEX idx_scenarios_status ON cross_border_scenarios(status);
CREATE INDEX idx_scenarios_country ON cross_border_scenarios(recipient_country);
CREATE INDEX idx_scenarios_created_by ON cross_border_scenarios(created_by);
CREATE INDEX idx_scenarios_expiry ON cross_border_scenarios(expiry_date);

-- 审计日志表索引
CREATE INDEX idx_audit_logs_user ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_timestamp ON audit_logs(timestamp);
CREATE INDEX idx_audit_logs_resource ON audit_logs(resource_type, resource_id);
```

## 4. API设计

### 4.1 设计原则

1. **RESTful风格**：遵循REST架构风格
2. **版本控制**：使用URL路径版本控制（/api/v1/）
3. **统一响应格式**：所有API返回统一的响应格式
4. **错误处理**：明确的HTTP状态码和错误信息
5. **分页支持**：列表接口支持分页查询

### 4.2 统一响应格式

```json
{
  "code": 200,
  "message": "success",
  "data": {
    // 具体数据
  },
  "pagination": {
    "page": 1,
    "size": 20,
    "total": 100,
    "pages": 5
  }
}
```

### 4.3 API接口设计

#### 4.3.1 认证相关接口

```
POST /api/v1/auth/login          # 用户登录
POST /api/v1/auth/logout         # 用户登出
POST /api/v1/auth/refresh        # 刷新token
GET  /api/v1/auth/profile        # 获取用户信息
PUT  /api/v1/auth/profile        # 更新用户信息
```

#### 4.3.2 数据资产相关接口

```
GET    /api/v1/data-assets              # 获取资产列表
POST   /api/v1/data-assets              # 创建资产
GET    /api/v1/data-assets/{id}         # 获取资产详情
PUT    /api/v1/data-assets/{id}         # 更新资产
DELETE /api/v1/data-assets/{id}         # 删除资产
POST   /api/v1/data-assets/scan         # 扫描资产
GET    /api/v1/data-assets/classifications  # 获取分类列表
GET    /api/v1/data-assets/tags         # 获取标签列表
```

#### 4.3.3 场景管理相关接口

```
GET    /api/v1/scenarios                 # 获取场景列表
POST   /api/v1/scenarios                 # 创建场景
GET    /api/v1/scenarios/{id}            # 获取场景详情
PUT    /api/v1/scenarios/{id}            # 更新场景
DELETE /api/v1/scenarios/{id}            # 删除场景
POST   /api/v1/scenarios/{id}/submit     # 提交审批
POST   /api/v1/scenarios/{id}/approve    # 批准场景
POST   /api/v1/scenarios/{id}/reject     # 拒绝场景
```

#### 4.3.4 风险评估相关接口

```
GET    /api/v1/risk-assessments           # 获取评估列表
POST   /api/v1/risk-assessments           # 创建评估
GET    /api/v1/risk-assessments/{id}      # 获取评估详情
PUT    /api/v1/risk-assessments/{id}      # 更新评估
POST   /api/v1/risk-assessments/{id}/calculate  # 执行评估计算
GET    /api/v1/risk-assessments/{id}/threshold-check  # 检查阈值
```

#### 4.3.5 审批相关接口

```
GET    /api/v1/approvals                  # 获取审批列表
POST   /api/v1/approvals                  # 创建审批申请
GET    /api/v1/approvals/{id}             # 获取审批详情
POST   /api/v1/approvals/{id}/approve    # 批准传输
POST   /api/v1/approvals/{id}/reject     # 拒绝传输
POST   /api/v1/approvals/batch            # 批量审批
```

#### 4.3.6 监控审计相关接口

```
GET    /api/v1/dashboard/overview         # 获取概览统计
GET    /api/v1/dashboard/transfer-trends # 获取传输趋势
GET    /api/v1/dashboard/country-distribution  # 获取目的国分布
GET    /api/v1/dashboard/risk-alerts     # 获取风险预警
GET    /api/v1/audit                      # 获取审计日志
GET    /api/v1/audit/statistics           # 获取审计统计
GET    /api/v1/audit/anomalies            # 获取异常行为
```

### 4.4 错误处理

#### 4.4.1 HTTP状态码

| 状态码 | 含义 | 使用场景 |
|--------|------|----------|
| 200 | OK | 请求成功 |
| 201 | Created | 资源创建成功 |
| 204 | No Content | 删除成功 |
| 400 | Bad Request | 请求参数错误 |
| 401 | Unauthorized | 未授权 |
| 403 | Forbidden | 禁止访问 |
| 404 | Not Found | 资源不存在 |
| 409 | Conflict | 资源冲突 |
| 422 | Unprocessable Entity | 数据验证失败 |
| 429 | Too Many Requests | 请求频率限制 |
| 500 | Internal Server Error | 服务器内部错误 |

#### 4.4.2 错误响应格式

```json
{
  "code": 400,
  "message": "Bad Request",
  "error": {
    "type": "ValidationError",
    "details": [
      {
        "field": "email",
        "message": "邮箱格式不正确"
      }
    ]
  }
}
```

## 5. 安全设计

### 5.1 认证与授权

#### 5.1.1 JWT Token认证

```python
class JWTManager:
    """JWT管理器"""

    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm
        self.access_token_expire_minutes = 30
        self.refresh_token_expire_days = 7

    def create_access_token(self, data: dict) -> str:
        """创建访问token"""
        to_encode = data.copy()
        expire = datetime.utcnow() + timedelta(minutes=self.access_token_expire_minutes)
        to_encode.update({"exp": expire, "type": "access"})
        return jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)

    def create_refresh_token(self, data: dict) -> str:
        """创建刷新token"""
        to_encode = data.copy()
        expire = datetime.utcnow() + timedelta(days=self.refresh_token_expire_days)
        to_encode.update({"exp": expire, "type": "refresh"})
        return jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)

    def verify_token(self, token: str) -> dict:
        """验证token"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            raise AuthenticationError("Token已过期")
        except jwt.InvalidTokenError:
            raise AuthenticationError("无效的Token")
```

#### 5.1.2 权限控制

```python
class PermissionChecker:
    """权限检查器"""

    def __init__(self, session: Session):
        self.session = session

    def check_permission(self, user_id: int, resource: str, action: str) -> bool:
        """检查用户权限"""
        # 查询用户角色
        user_roles = self.session.query(UserRole).filter(
            UserRole.user_id == user_id,
            UserRole.is_active == True
        ).all()

        # 查询角色权限
        role_ids = [ur.role_id for ur in user_roles]
        permissions = self.session.query(RolePermission).filter(
            RolePermission.role_id.in_(role_ids)
        ).all()

        # 检查是否有对应权限
        for rp in permissions:
            if rp.permission.resource == resource and rp.permission.action == action:
                return True

        return False
```

### 5.2 数据安全

#### 5.2.1 敏感数据加密

```python
class DataEncryption:
    """数据加密器"""

    def __init__(self, key: bytes):
        self.key = key
        self.cipher_suite = Fernet(key)

    def encrypt_sensitive_data(self, data: str) -> str:
        """加密敏感数据"""
        return self.cipher_suite.encrypt(data.encode()).decode()

    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """解密敏感数据"""
        return self.cipher_suite.decrypt(encrypted_data.encode()).decode()
```

#### 5.2.2 SQL注入防护

使用SQLAlchemy的参数化查询，避免SQL注入：

```python
# 安全的查询方式
def get_user_by_username(self, username: str):
    return self.session.query(User).filter(
        User.username == username
    ).first()

# 避免不安全的字符串拼接
# 错误示例：
# query = f"SELECT * FROM users WHERE username = '{username}'"
```

### 5.3 访问控制

#### 5.3.1 IP白名单

```python
class IPWhitelist:
    """IP白名单管理"""

    def __init__(self):
        self.allowed_ips = [
            "127.0.0.1",
            "10.0.0.0/8",
            "172.16.0.0/12",
            "192.168.0.0/16"
        ]

    def is_allowed(self, ip: str) -> bool:
        """检查IP是否在白名单中"""
        import ipaddress
        client_ip = ipaddress.ip_address(ip)

        for allowed in self.allowed_ips:
            try:
                allowed_ip = ipaddress.ip_network(allowed)
                if client_ip in allowed_ip:
                    return True
            except ValueError:
                # 如果是具体IP地址
                if str(client_ip) == allowed:
                    return True

        return False
```

#### 5.3.2 请求频率限制

```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@app.get("/api/v1/data-assets")
@limiter.limit("100/minute")
async def get_data_assets():
    """限制每分钟100次请求"""
    pass
```

## 6. 性能优化设计

### 6.1 数据库优化

#### 6.1.1 索引优化

1. **主键索引**：所有表都有主键索引
2. **外键索引**：所有外键字段都创建索引
3. **查询索引**：根据常用查询条件创建复合索引
4. **避免过多索引**：索引会降低写入性能

#### 6.1.2 查询优化

```python
# 使用查询优化
def get_data_assets_with_pagination(
    page: int = 1,
    size: int = 20,
    filters: dict = None
):
    """分页查询数据资产"""
    query = self.session.query(DataAsset)

    # 添加过滤条件
    if filters:
        if filters.get('name'):
            query = query.filter(DataAsset.asset_name.ilike(f"%{filters['name']}%"))
        if filters.get('level'):
            query = query.filter(DataAsset.data_level == filters['level'])
        if filters.get('classification_id'):
            query = query.filter(DataAsset.classification_id == filters['classification_id'])

    # 使用分页
    offset = (page - 1) * size
    total = query.count()
    items = query.offset(offset).limit(size).all()

    return {
        'items': items,
        'total': total,
        'page': page,
        'size': size,
        'pages': (total + size - 1) // size
    }
```

### 6.2 缓存策略

#### 6.2.1 Redis缓存

```python
import redis
import json
from typing import Optional, Any

class CacheManager:
    """缓存管理器"""

    def __init__(self, redis_url: str):
        self.redis_client = redis.from_url(redis_url)
        self.default_expire = 3600  # 1小时

    def get(self, key: str) -> Optional[Any]:
        """获取缓存"""
        data = self.redis_client.get(key)
        if data:
            return json.loads(data)
        return None

    def set(self, key: str, value: Any, expire: int = None):
        """设置缓存"""
        expire = expire or self.default_expire
        self.redis_client.setex(
            key,
            expire,
            json.dumps(value, default=str)
        )

    def delete(self, key: str):
        """删除缓存"""
        self.redis_client.delete(key)

    def clear_pattern(self, pattern: str):
        """清理匹配模式的缓存"""
        keys = self.redis_client.keys(pattern)
        if keys:
            self.redis_client.delete(*keys)
```

#### 6.2.2 缓存使用场景

1. **用户会话**：用户登录信息、权限信息
2. **配置信息**：系统配置、字典数据
3. **统计数据**：仪表盘统计数据、实时监控数据
4. **查询结果**：复杂查询结果缓存

### 6.3 异步处理

#### 6.3.1 Celery任务队列

```python
from celery import Celery

celery_app = Celery("datareg")

@celery_app.task
def scan_database_task(db_config: dict):
    """异步扫描数据库任务"""
    scanner = DataScanner()
    results = scanner.scan_database(db_config)
    return results

@celery_app.task
def send_notification_task(user_id: int, message: str):
    """异步发送通知任务"""
    notification_service = NotificationService()
    notification_service.send(user_id, message)

@celery_app.task
def generate_report_task(report_type: str, params: dict):
    """异步生成报告任务"""
    report_generator = ReportGenerator()
    report = report_generator.generate(report_type, params)
    return report
```

#### 6.3.2 定时任务

```python
from celery.schedules import crontab

# 每天凌晨检查过期的场景
celery_app.conf.beat_schedule = {
    'check-expired-scenarios': {
        'task': 'tasks.scenario.check_expired_scenarios',
        'schedule': crontab(hour=0, minute=0),
    },
    'generate-daily-report': {
        'task': 'tasks.report.generate_daily_report',
        'schedule': crontab(hour=1, minute=0),
    },
    'cleanup-audit-logs': {
        'task': 'tasks.audit.cleanup_old_logs',
        'schedule': crontab(hour=2, minute=0, day_of_week=0),  # 每周日凌晨
    },
}
```

## 7. 监控与日志设计

### 7.1 日志设计

#### 7.1.1 日志级别

- **DEBUG**：调试信息，开发阶段使用
- **INFO**：一般信息，记录系统正常运行状态
- **WARNING**：警告信息，可能的问题但不影响系统运行
- **ERROR**：错误信息，系统出现问题但不影响主要功能
- **CRITICAL**：严重错误，系统无法正常运行

#### 7.1.2 日志格式

```python
import logging
import json
from datetime import datetime

class JSONFormatter(logging.Formatter):
    """JSON格式化器"""

    def format(self, record):
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'level': record.levelname,
            'logger': record.name,
            'message': record.getMessage(),
            'module': record.module,
            'function': record.funcName,
            'line': record.lineno,
        }

        if hasattr(record, 'user_id'):
            log_data['user_id'] = record.user_id

        if hasattr(record, 'request_id'):
            log_data['request_id'] = record.request_id

        if record.exc_info:
            log_data['exception'] = self.formatException(record.exc_info)

        return json.dumps(log_data, ensure_ascii=False)
```

#### 7.1.3 审计日志

```python
class AuditLogger:
    """审计日志记录器"""

    def __init__(self, session: Session):
        self.session = session

    def log_action(
        self,
        user_id: int,
        action: str,
        resource_type: str,
        resource_id: int,
        details: dict = None
    ):
        """记录用户操作"""
        audit_log = AuditLog(
            user_id=user_id,
            action=action,
            resource_type=resource_type,
            resource_id=resource_id,
            details=details or {},
            ip_address=get_remote_address(),
            user_agent=get_user_agent(),
            timestamp=datetime.utcnow()
        )
        self.session.add(audit_log)
        self.session.commit()
```

### 7.2 监控设计

#### 7.2.1 系统监控指标

```python
from prometheus_client import Counter, Histogram, Gauge

# 请求计数器
REQUEST_COUNT = Counter(
    'http_requests_total',
    'Total HTTP requests',
    ['method', 'endpoint', 'status']
)

# 请求延迟
REQUEST_LATENCY = Histogram(
    'http_request_duration_seconds',
    'HTTP request latency'
)

# 活跃用户数
ACTIVE_USERS = Gauge(
    'active_users_total',
    'Number of active users'
)

# 数据库连接池
DB_CONNECTION_POOL = Gauge(
    'db_connections_active',
    'Active database connections'
)
```

#### 7.2.2 健康检查

```python
@app.get("/health")
async def health_check():
    """健康检查接口"""
    health_status = {
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat(),
        'checks': {}
    }

    # 检查数据库连接
    try:
        db.execute("SELECT 1")
        health_status['checks']['database'] = 'healthy'
    except Exception as e:
        health_status['status'] = 'unhealthy'
        health_status['checks']['database'] = f'unhealthy: {str(e)}'

    # 检查Redis连接
    try:
        redis_client.ping()
        health_status['checks']['redis'] = 'healthy'
    except Exception as e:
        health_status['status'] = 'unhealthy'
        health_status['checks']['redis'] = f'unhealthy: {str(e)}'

    status_code = 200 if health_status['status'] == 'healthy' else 503
    return JSONResponse(content=health_status, status_code=status_code)
```

## 8. 部署设计

### 8.1 容器化部署

#### 8.1.1 Dockerfile

```dockerfile
# 后端Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# 安装Python依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建非root用户
RUN useradd --create-home --shell /bin/bash app \
    && chown -R app:app /app
USER app

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```dockerfile
# 前端Dockerfile
FROM node:18-alpine as builder

WORKDIR /app

# 安装依赖
COPY package*.json ./
RUN npm ci --only=production

# 构建应用
COPY . .
RUN npm run build

# 生产镜像
FROM nginx:alpine

# 复制构建结果
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制nginx配置
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

#### 8.1.2 Docker Compose

```yaml
version: '3.8'

services:
  db:
    image: postgres:14
    environment:
      POSTGRES_DB: datareg
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: 3f342bb206
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"

  backend:
    build: ./backend
    environment:
      DATABASE_URL: postgresql://postgres:3f342bb206@db:5432/datareg
      REDIS_URL: redis://redis:6379
      SECRET_KEY: your-secret-key
    depends_on:
      - db
      - redis
    ports:
      - "8000:8000"
    volumes:
      - ./backend:/app

  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend

  celery:
    build: ./backend
    command: celery -A app.main.celery worker --loglevel=info
    environment:
      DATABASE_URL: postgresql://postgres:3f342bb206@db:5432/datareg
      REDIS_URL: redis://redis:6379
    depends_on:
      - db
      - redis
    volumes:
      - ./backend:/app

  celery-beat:
    build: ./backend
    command: celery -A app.main.celery beat --loglevel=info
    environment:
      DATABASE_URL: postgresql://postgres:3f342bb206@db:5432/datareg
      REDIS_URL: redis://redis:6379
    depends_on:
      - db
      - redis
    volumes:
      - ./backend:/app

volumes:
  postgres_data:
```

### 8.2 生产环境部署

#### 8.2.1 Kubernetes部署

```yaml
# backend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: datareg-backend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: datareg-backend
  template:
    metadata:
      labels:
        app: datareg-backend
    spec:
      containers:
      - name: backend
        image: datareg/backend:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: datareg-secrets
              key: database-url
        - name: SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: datareg-secrets
              key: secret-key
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5
```

#### 8.2.2 监控部署

```yaml
# monitoring.yaml
apiVersion: v1
kind: ServiceMonitor
metadata:
  name: datareg-monitoring
spec:
  selector:
    matchLabels:
      app: datareg-backend
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
```

## 9. 测试设计

### 9.1 测试策略

1. **单元测试**：覆盖业务逻辑和数据访问层
2. **集成测试**：测试API接口和数据库交互
3. **端到端测试**：测试完整业务流程
4. **性能测试**：测试系统性能和并发能力
5. **安全测试**：测试系统安全性

### 9.2 测试工具

```python
# 使用pytest进行单元测试
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_create_user():
    """测试创建用户"""
    response = client.post(
        "/api/v1/users",
        json={
            "username": "testuser",
            "email": "test@example.com",
            "password": "test123"
        }
    )
    assert response.status_code == 201
    assert response.json()["username"] == "testuser"

def test_login():
    """测试用户登录"""
    response = client.post(
        "/api/v1/auth/login",
        json={
            "username": "testuser",
            "password": "test123"
        }
    )
    assert response.status_code == 200
    assert "access_token" in response.json()
```

### 9.3 自动化测试

```yaml
# .github/workflows/test.yml
name: Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        cd backend
        pip install -r requirements.txt

    - name: Run tests
      run: |
        cd backend
        pytest
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost/test
```

---

**文档版本**: 1.0
**最后更新**: 2024年12月23日
**编写人**: 张彦龙